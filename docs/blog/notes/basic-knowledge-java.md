# 基础知识（Java篇）
## GC机制（垃圾回收机制）
+ 找到垃圾的方法：引用计数法、可达性分析法
+ 回收垃圾的方法：标记清除算法、复制算法、标记整理法、分代算法

## JVM内存划分
+ 线程私有：程序计数器、JVM虚拟机栈、本地方法栈
+ 线程公有：堆、方法区、运行时常量池

## 会发生OOM的区域
+ 堆：内存泄漏
+ JVM虚拟机栈和本地方法栈：递归循环
+ 方法区：早期类加载过多会OOM，现在一般不会

## 类加载过程
1. 加载：将字节码数据从不同的数据源读取到JVM内存，并映射为JVM认可的数据结构
2. 链接：
    1. 验证：校验字节信息是否符合规范，避免恶意信息和不规范数据危害JVM运行安全
    2. 准备：创建静态变量，并为静态变量开辟内存空间
    3. 解析：将符号引用替换为直接引用
3. 初始化：为静态变量赋值，并执行静态代码块中的逻辑

## 双亲委派模型
1. 类加载器分类
    + 启动类加载器：主要加载jre/lib下的jar文件
    + 扩展类加载器：主要加载jre/lib/ext下的jar文件
    + 应用程序类加载器：主要加载classpath下的文件
2. 双亲委派模型：当加载一个类时，优先使用父类加载器加载，当父类加载器无法加载时才使用子类加载器去加载

## HashMap的原理
+ 可以看作是数组+链表的组合。数组被分为一个个的桶。哈希值决定了键值对在数组中的寻址。具有相同哈希值的键值对会组成链表（避免哈希冲突）。当链表长度超过阈值（默认是8）的时候会触发树化，链表会变成树形结构。

## HashMap需要关注的4个方法
1. hash方法
    + 将key的hashCode值的高位数据移位到低位进行异或运算。这么做的原因是有些key的hashCode值的差异集中在高位，而哈希寻址是忽略容量以上高位的，这种做法可以有效避免哈希冲突

2. put方法（步骤）
    1. 通过hash方法获取hash值，根据hash值寻址
    2. 如果未发生碰撞，直接放到桶中
    3. 如果发生碰撞，则以链表形式放在桶后
    4. 当链表长度大于阈值后会触发树化，将链表转换为红黑树
    5. 如果数组长度达到阈值，会调用resize方法扩容
3. get方法（步骤）
    1. 通过hash方法获取hash值，根据hash值寻址
    2. 如果与寻址到桶的key相同，直接返回对应的value
    3. 如果发生冲突，分两种情况。如果是树，则调用getTreeNode获取value；如果是链表，则循环遍历查找对应的value
4. resize方法（步骤）
    1. 将原数组扩展为原来的2倍
    2. 重新计算index索引值，将原节点重新放到新的数组中。这一步可以将原先冲突的节点分散到新的桶中 
    
## sleep和wait的区别
+ sleep方法是Thread类中的静态方法，wait是Object类中的方法
+ sleep并不会释放同步锁，而wait会释放同步锁
+ sleep可以在任何地方使用，而wait方法只能在同步方法或者同步方法块中使用
+ sleep中必须传入时间，而wait可以传也可以不传，不传时间的话只有notify或者notifyAll才能唤醒，传时间的话在时间之后会自动唤醒

## final、finally、finalize的区别
+ final可以修饰类、变量和方法。修饰类代表这个类不可被继承，修饰变量代表此变量不可被改变，修饰方法表示此方法不可被重写（override）
+ finally是保证重点代码一定会执行的一种机制。通常是使用try-finally或者try-catch-finally来进行文件流的关闭等操作
+ finalize是Object类中的一个方法。它的设计目的是保证对象在垃圾回收前完成特定资源的回收。finalize机制已不推荐使用，并且在JDK9已经被标记为deprecated

## 常见的单例模式
+ 饿汉式、双重判断的懒汉式、静态内部类实现的单例（<span style="color: #ff0000;">最推荐的方式</span>）、枚举实现的单例

<span style="background-color: #ffff00;">单例对象实例需要有volatile修饰，是因为：mInstance = new SingleTon()包含三个操作（给mInstance分配内存，调用SingleTon的构造方法初始化成员变量，将mInstance指向分配的内存空间），又由于JVM会发生指令重排，所以可能调用顺序会发生错误。这样会导致报错。而volatile的作用有保持可见性和禁止指令重排</span>

## java中引用类型的区别
+ 强引用：指的是通过new对象创建的引用，垃圾回收器即使在内存不足的情况下也不会回收具有强引用的对象
+ 软引用：是通过SoftRefrence实现的，在内存不足之前会被垃圾回收器回收。可用于存储一些内存敏感的缓存
+ 弱引用：是通过WeakRefrence实现的，垃圾回收器只要扫描到就会将其回收。可用于存储一些内存敏感的缓存
+ 虚引用：是通过FanttomRefrence实现的，随时有可能被回收。可用于跟踪对象被垃圾回收的活动，当一个虚引用关联的对象被GC回收之前会受到一条系统通知

## volatile的原理是在生成的汇编代码中多了一个lock前缀指令，这个前缀指令相当于一个内存屏障，这个屏障有三个作用
1. 确保指令重排的时候不会把屏障后的指令排在屏障前，确保不会把屏障前的指令排在屏障后
2. 修改缓存中的共享变量后立即刷新到主存中
3. 当执行写操作时会导致其他CPU中的缓存无效

## http与https的区别
+ https需要CA证书，很少免费，需要一定费用
+ http是明文传输，安全性低；而https是http的基础上通过ssl加密，安全性高
+ 默认端口不同。http是80，https是443

## https的加密算法
+ 称加密：加密和解密用的都是相同的秘钥，优点是速度快，缺点是安全性低。常见的算法有DES、AES等等
+ 非对称加密：非对称加密有一个密钥对，分为公钥和私钥。一般来说，私钥自己持有，公钥可以公开给对方，优点是安全性比对称加密高，缺点是数据传输效率比对称加密低。采用公钥加密的信息只有对应的私钥可以解密。常见的算法有RSA等

<span style="background-color: #ffff00; color: #000000;">正式场景中一般都是采用对称加密和非对称加密结合的方式，使用非对称加密来完成秘钥的传递，然后使用对称加密实现数据的传递。这样保证了安全性又提高了传输效率</span>

<Vssue title="基础知识（Java篇）" /> 